import { HardhatRuntimeEnvironment } from "hardhat/types";
import { Config, Domain } from "@buildwithsygma/sygma-sdk-core";
import Web3, {
  ContractAbi,
  Transaction,
  utils,
  PayableCallOptions,
} from "web3";
import { vars } from "hardhat/config";
import chalk from "chalk";
import terminalLink from "terminal-link";
import {
  getConfigEnvironmentVariable,
  getNetworkChainId,
  mapNetworkArgs,
  sumedFees,
  transferStatusInterval,
} from "./utils";
import { AdapterABI } from "./adapterABI";
import { DeployOptions, DeploymentInfo, NetworkArguments } from "./types";

export class MultichainHardhatRuntimeEnvironmentField {
  private isValidated: boolean = false;
  private domains: Domain[] = [];
  private readonly web3: Web3 | null;

  public constructor(private readonly hre: HardhatRuntimeEnvironment) {
    const provider = this.hre.network.provider;
    this.web3 = new Web3(provider);
  }

  public ADAPTER_ADDRESS = vars.get(
    "ADAPTER_ADDRESS",
    "0x85d62ad850b322152bf4ad9147bfbf097da42217"
  );

  //current Sygma hardcoded gasLimit
  private gasLimit = 1000000;

  private async validateConfig(): Promise<void> {
    const originChainId = await getNetworkChainId(
      this.hre.network.name,
      this.hre
    );
    const environment = getConfigEnvironmentVariable(this.hre);

    const config = new Config();
    await config.init(originChainId, environment);

    this.domains = config.getDomains();

    this.isValidated;
  }

  /**
   * @param contractName name of the contract
   * @param networkArgs record key is name of the networks on which contract is being deployed
   * @param args contract contructor args
   * @param initData optional init method details, method name and args required
   * @param salt optional or generated by default from randombytes(32)
   * @param isUniquePerChain optional
   * @param customNonPayableTxOptions non payable options for web3 deploy.method.send(), payable summed fees are always calculated by the method
   */
  public async deployMultichain<Abi extends ContractAbi = any>(
    contractName: string,
    networkArgs: NetworkArguments<Abi>,
    options?: DeployOptions
  ): Promise<{
    deploymentInfo: DeploymentInfo[];
    receipt: Transaction;
  } | void> {
    const artifact = this.hre.artifacts.readArtifactSync(contractName);

    return this.deployMultichainBytecode(
      artifact.bytecode,
      artifact.abi as unknown as Abi,
      networkArgs,
      options
    );
  }

  public async deployMultichainBytecode<Abi extends ContractAbi = any>(
    contractBytecode: string,
    contractAbi: Abi,
    networkArgs: NetworkArguments<Abi>,
    options?: DeployOptions
  ): Promise<{
    deploymentInfo: DeploymentInfo[];
    receipt: Transaction;
  } | void> {
    if (!this.isValidated) await this.validateConfig();
    if (!this.web3) return;

    //optional params
    const salt = options?.salt ?? utils.randomBytes(32);
    const isUniquePerChain = options?.isUniquePerChain ?? false;

    //adapter contract
    const adapterContract = new this.web3.eth.Contract<typeof AdapterABI>(
      AdapterABI,
      this.ADAPTER_ADDRESS
    );

    const { constructorArgs, initDatas, deployDomainIDs } = mapNetworkArgs(
      contractAbi,
      networkArgs,
      this.domains
    );

    const fees = await adapterContract.methods
      .calculateDeployFee(
        contractBytecode,
        this.gasLimit,
        salt,
        isUniquePerChain,
        constructorArgs,
        initDatas,
        deployDomainIDs
      )
      .call();

    let payableTxOptions: PayableCallOptions = { value: sumedFees(fees) };

    if (options?.customNonPayableTxOptions) {
      payableTxOptions = {
        ...options.customNonPayableTxOptions,
        value: sumedFees(fees),
      };
    }
    console.log("Sending transaction...");
    const receipt = await adapterContract.methods
      .deploy(
        contractBytecode,
        this.gasLimit,
        salt,
        isUniquePerChain,
        constructorArgs,
        initDatas,
        deployDomainIDs,
        fees
      )
      .send(payableTxOptions);
    const networkNames = Object.keys(networkArgs);
    const { transactionHash } = receipt;
    console.log(
      `Multichain deployment initiated, transaction hash: ${chalk.bold(
        transactionHash
      )}
      
      ` +
        "\n" +
        "Destinaton networks:" +
        networkNames.join("\r\n")
    );

    const [deployer] = await this.web3.eth.getAccounts();

    const destinationDomainChainIDs = deployDomainIDs.map((deployDomainID) => {
      const deployDomain: Domain = this.domains.find(
        (domain) => BigInt(domain.id) === deployDomainID
      )!;
      return deployDomain.chainId;
    });

    const deploymentInfo: DeploymentInfo[] = await Promise.all(
      destinationDomainChainIDs.map(async (domainChainID, index) => {
        const network = networkNames[index];

        const contractAddress = await adapterContract.methods
          .computeContractAddressForChain(
            deployer,
            salt,
            isUniquePerChain,
            domainChainID
          )
          .call();
        console.log(
          `Contract deploying on ${chalk.bold(
            network.toUpperCase()
          )}: ${chalk.bold(contractAddress)}`
        );

        const explorerUrl = await transferStatusInterval(
          this.hre.config.multichain.environment,
          transactionHash,
          domainChainID
        );
        const explorerLink = terminalLink(explorerUrl, explorerUrl);
        console.log(
          `Bridge transfer executed. More details: ${chalk.underline(
            explorerLink
          )}`
        );

        return {
          network,
          contractAddress,
          explorerUrl,
          transactionHash,
        };
      })
    );

    return {
      receipt,
      deploymentInfo,
    };
  }
}
